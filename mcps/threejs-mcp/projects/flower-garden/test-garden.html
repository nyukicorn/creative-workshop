<!DOCTYPE html>
<html>
<head>
    <title>ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«åº­åœ’ãƒ†ã‚¹ãƒˆ</title>
    <style>
        body { margin: 0; background: #000; }
        #info { position: absolute; top: 10px; left: 10px; color: white; z-index: 100; }
    </style>
</head>
<body>
    <div id="info">
        <h3>ğŸŒº ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«åº­åœ’ ğŸŒº</h3>
        <p>æ¥ç¶šçŠ¶æ…‹: <span id="status">æœªæ¥ç¶š</span></p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Three.jsåŸºæœ¬è¨­å®š
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        // ã‚«ãƒ¡ãƒ©ä½ç½®
        camera.position.set(5, 5, 5);
        camera.lookAt(0, 0, 0);
        
        // ãƒ©ã‚¤ãƒˆ
        const light = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(light);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);
        
        // ãƒ†ã‚¹ãƒˆç”¨ã‚­ãƒ¥ãƒ¼ãƒ–
        const geometry = new THREE.BoxGeometry();
        const material = new THREE.MeshLambertMaterial({color: 0x00ff00});
        const cube = new THREE.Mesh(geometry, material);
        scene.add(cube);
        
        // WebSocketæ¥ç¶š
        const ws = new WebSocket('ws://localhost:8082');
        const statusEl = document.getElementById('status');
        
        ws.onopen = () => {
            statusEl.textContent = 'æ¥ç¶šä¸­';
            statusEl.style.color = 'green';
            console.log('WebSocketæ¥ç¶šæˆåŠŸ');
        };
        
        ws.onmessage = (event) => {
            const command = JSON.parse(event.data);
            console.log('å—ä¿¡:', command);
            handleCommand(command);
        };
        
        ws.onerror = (error) => {
            statusEl.textContent = 'ã‚¨ãƒ©ãƒ¼';
            statusEl.style.color = 'red';
            console.error('WebSocketã‚¨ãƒ©ãƒ¼:', error);
        };
        
        // ã‚³ãƒãƒ³ãƒ‰å‡¦ç†
        function handleCommand(command) {
            console.log('å‡¦ç†ä¸­:', command.action);
            if (command.action === 'createMagicDust') {
                createMagicDust();
            } else if (command.action === 'createFlowerParticles') {
                createFlowerParticles(command);
            } else if (command.action === 'createStemParticles') {
                createStemParticles(command);
            } else if (command.action === 'createFallingPetals') {
                createFallingPetals(command);
            } else if (command.action === 'createLeafParticles') {
                createLeafParticles(command);
            } else if (command.action === 'createGrassParticles') {
                createGrassParticles(command);
            } else {
                console.log('æœªå¯¾å¿œã‚³ãƒãƒ³ãƒ‰:', command.action);
            }
        }
        
        // é­”æ³•ã®ç²‰
        function createMagicDust() {
            const particles = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            
            // ã‚«ãƒ¡ãƒ©ã®è¿‘ãã«å¤§ããªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ä½œæˆ
            for (let i = 0; i < 100; i++) {
                positions.push(
                    (Math.random() - 0.5) * 10,  // ã‚ˆã‚Šç‹­ã„ç¯„å›²
                    Math.random() * 5,           // ã‚ˆã‚Šä½ã„é«˜ã•
                    (Math.random() - 0.5) * 10
                );
                colors.push(1.0, 1.0, 1.0);     // ç™½è‰²ã§çµ±ä¸€
            }
            
            particles.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 1.0,                       // å¤§ããªã‚µã‚¤ã‚º
                vertexColors: true,
                sizeAttenuation: false           // è·é›¢ã«ã‚ˆã‚‹ç¸®å°ã‚’ç„¡åŠ¹
            });
            
            const points = new THREE.Points(particles, material);
            scene.add(points);
            console.log('âœ¨ é­”æ³•ã®ç²‰ã‚’ä½œæˆ - ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°:', positions.length/3);
            console.log('ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ä½ç½®ä¾‹:', positions.slice(0, 9));
        }
        
        // èŠ±ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
        function createFlowerParticles(command) {
            const particles = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const color = new THREE.Color(command.color);
            
            for (let i = 0; i < 100; i++) {
                const angle = (i / 100) * Math.PI * 2;
                const radius = 0.5;
                positions.push(
                    command.position[0] + Math.cos(angle) * radius,
                    command.position[1],
                    command.position[2] + Math.sin(angle) * radius
                );
                colors.push(color.r, color.g, color.b);
            }
            
            particles.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true
            });
            
            const points = new THREE.Points(particles, material);
            scene.add(points);
            console.log('ğŸŒ¸ èŠ±ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ä½œæˆ:', command.id);
        }
        
        // èŒãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
        function createStemParticles(command) {
            const particles = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const color = new THREE.Color(command.color);
            const start = command.startPos;
            const end = command.endPos;
            
            for (let i = 0; i <= 20; i++) {
                const t = i / 20;
                positions.push(
                    start[0] + (end[0] - start[0]) * t,
                    start[1] + (end[1] - start[1]) * t,
                    start[2] + (end[2] - start[2]) * t
                );
                colors.push(color.r, color.g, color.b);
            }
            
            particles.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({ size: 0.15, vertexColors: true });
            const points = new THREE.Points(particles, material);
            scene.add(points);
            console.log('ğŸŒ¿ èŒãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ä½œæˆ:', command.id);
        }
        
        // æ•£ã‚‹èŠ±ã³ã‚‰
        function createFallingPetals(command) {
            const particles = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const color = new THREE.Color(command.color);
            const center = command.position;
            
            for (let i = 0; i < command.count; i++) {
                positions.push(
                    center[0] + (Math.random() - 0.5) * 2,
                    center[1] + Math.random() * 2,
                    center[2] + (Math.random() - 0.5) * 2
                );
                colors.push(color.r, color.g, color.b);
            }
            
            particles.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({ size: 0.08, vertexColors: true });
            const points = new THREE.Points(particles, material);
            scene.add(points);
            console.log('ğŸŒ¸ æ•£ã‚‹èŠ±ã³ã‚‰ã‚’ä½œæˆ:', command.id);
        }
        
        // è‘‰ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«  
        function createLeafParticles(command) {
            const particles = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const color = new THREE.Color(command.color);
            const center = command.position;
            
            for (let i = 0; i < 20; i++) {
                positions.push(
                    center[0] + (Math.random() - 0.5) * 0.5,
                    center[1],
                    center[2] + (Math.random() - 0.5) * 0.5
                );
                colors.push(color.r, color.g, color.b);
            }
            
            particles.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({ size: 0.12, vertexColors: true });
            const points = new THREE.Points(particles, material);
            scene.add(points);
            console.log('ğŸƒ è‘‰ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ä½œæˆ:', command.id);
        }
        
        // è‰ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
        function createGrassParticles(command) {
            const particles = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const color = new THREE.Color(command.color);
            const center = command.position;
            const density = command.density === 'dense' ? 30 : command.density === 'sparse' ? 10 : 20;
            
            for (let i = 0; i < density; i++) {
                positions.push(
                    center[0] + (Math.random() - 0.5) * 0.5,
                    center[1] + Math.random() * 0.3,
                    center[2] + (Math.random() - 0.5) * 0.5
                );
                colors.push(color.r, color.g, color.b);
            }
            
            particles.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({ size: 0.08, vertexColors: true });
            const points = new THREE.Points(particles, material);
            scene.add(points);
            console.log('ğŸŒ± è‰ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ä½œæˆ:', command.id);
        }

        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
        function animate() {
            requestAnimationFrame(animate);
            cube.rotation.x += 0.01;
            cube.rotation.y += 0.01;
            renderer.render(scene, camera);
        }
        animate();
        
        // ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>