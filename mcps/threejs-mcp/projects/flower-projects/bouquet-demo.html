<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸŒ¹ğŸ’ å¦–ç²¾ä¼šç¤¾ Bouquet Three.js Demo</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000000; /* å®Œå…¨ã«é»’èƒŒæ™¯ */
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 300px;
        }
        #status {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
        .connected { color: #4ade80; }
        .disconnected { color: #f87171; }
    </style>
</head>
<body>
    <div id="container">
        <div id="info">
            <h3>ğŸŒ¹ğŸ’ å¦–ç²¾ä¼šç¤¾ Bouquet Demo</h3>
            <p><strong>æ¥ç¶šçŠ¶æ…‹:</strong> <span id="connection-status" class="disconnected">æœªæ¥ç¶š</span></p>
            <p><strong>æ“ä½œæ–¹æ³•:</strong></p>
            <ul>
                <li>ãƒã‚¦ã‚¹: ã‚«ãƒ¡ãƒ©å›è»¢</li>
                <li>ãƒ›ã‚¤ãƒ¼ãƒ«: ã‚ºãƒ¼ãƒ </li>
                <li>Claude CodeçµŒç”±ã§ãƒ–ãƒ¼ã‚±æ“ä½œ</li>
            </ul>
            <p><strong>ãƒ–ãƒ¼ã‚±ãƒ†ãƒ¼ãƒ:</strong></p>
            <p>ğŸŒ¹ ãƒãƒ© ğŸŒ· ãƒãƒ¥ãƒ¼ãƒªãƒƒãƒ— ğŸŒ» ã²ã¾ã‚ã‚Š ğŸŒº ãƒã‚¤ãƒ“ã‚¹ã‚«ã‚¹</p>
        </div>
        <div id="status">
            WebSocket: <span id="ws-status" class="disconnected">åˆ‡æ–­ä¸­</span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // Three.jsè¨­å®š
        let scene, camera, renderer, controls;
        let objects = new Map();
        let ws = null;

        // WebSocketæ¥ç¶š
        function connectWebSocket() {
            try {
                ws = new WebSocket('ws://localhost:8083'); // ç•°ãªã‚‹ãƒãƒ¼ãƒˆã‚’ä½¿ç”¨
                
                ws.onopen = function() {
                    console.log('WebSocketæ¥ç¶šæˆåŠŸ');
                    document.getElementById('ws-status').textContent = 'æ¥ç¶šä¸­';
                    document.getElementById('ws-status').className = 'connected';
                    document.getElementById('connection-status').textContent = 'æ¥ç¶šä¸­';
                    document.getElementById('connection-status').className = 'connected';
                    sendSceneState();
                };
                
                ws.onmessage = function(event) {
                    try {
                        let data = event.data;
                        console.log('Raw WebSocket data type:', typeof data, data);
                        
                        // Handle Blob data
                        if (data instanceof Blob) {
                            data.text().then(text => {
                                const command = JSON.parse(text);
                                console.log('WebSocketãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å—ä¿¡ (from Blob):', command);
                                handleCommand(command);
                            });
                        } else {
                            const command = JSON.parse(data);
                            console.log('WebSocketãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å—ä¿¡:', command);
                            handleCommand(command);
                        }
                    } catch (error) {
                        console.error('ã‚³ãƒãƒ³ãƒ‰è§£æã‚¨ãƒ©ãƒ¼:', error, 'Data:', event.data);
                    }
                };
                
                ws.onclose = function() {
                    console.log('WebSocketåˆ‡æ–­');
                    document.getElementById('ws-status').textContent = 'åˆ‡æ–­ä¸­';
                    document.getElementById('ws-status').className = 'disconnected';
                    document.getElementById('connection-status').textContent = 'æœªæ¥ç¶š';
                    document.getElementById('connection-status').className = 'disconnected';
                    setTimeout(connectWebSocket, 3000); // 3ç§’å¾Œã«å†æ¥ç¶š
                };
                
                ws.onerror = function(error) {
                    console.error('WebSocketã‚¨ãƒ©ãƒ¼:', error);
                };
                
            } catch (error) {
                console.error('WebSocketæ¥ç¶šå¤±æ•—:', error);
                setTimeout(connectWebSocket, 3000);
            }
        }

        // Three.jsåˆæœŸåŒ–
        function init() {
            // ã‚·ãƒ¼ãƒ³ä½œæˆ
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); // é»’èƒŒæ™¯

            // ã‚«ãƒ¡ãƒ©ä½œæˆ
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(3, 3, 5);

            // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ä½œæˆ
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ä½œæˆ
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 1, 0); // ãƒ–ãƒ¼ã‚±ã®ä¸­å¿ƒã‚’è¦‹ã‚‹

            // ãƒ©ã‚¤ãƒˆè¨­å®š
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(3, 5, 3);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // èƒŒæ™¯ç”»åƒãƒ—ãƒ¬ãƒ¼ãƒ³ï¼ˆ16:9ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ï¼‰
            const planeWidth = 8;
            const planeHeight = 4.5; // 16:9 = 8:4.5
            const bgGeometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
            let bgMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x888888,
                transparent: true,
                opacity: 0.1 // æœ€åˆã‹ã‚‰å°‘ã—è¦‹ãˆã‚‹
            });
            const bgPlane = new THREE.Mesh(bgGeometry, bgMaterial);
            bgPlane.position.set(0, 2, -2);
            bgPlane.receiveShadow = true;
            scene.add(bgPlane);
            
            // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¨ã—ã¦ä¿å­˜
            window.bgPlane = bgPlane;
            window.planeWidth = planeWidth;
            window.planeHeight = planeHeight;
            
            // åˆæœŸåŒ–æ™‚ã«è‡ªå‹•ã§èƒŒæ™¯ç”»åƒã¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’è¨­å®š
            setTimeout(() => {
                setBouquetBackground("http://localhost:8084/flower_bouquet.png");
                console.log('ğŸŒ¸ åˆæœŸåŒ–æ™‚ã«èƒŒæ™¯ç”»åƒã‚’è‡ªå‹•è¨­å®šã—ã¾ã—ãŸ');
                
                // 2ç§’å¾Œã«ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å¤‰æ›ã‚‚è‡ªå‹•å®Ÿè¡Œ
                setTimeout(() => {
                    convertImageToParticles("http://localhost:8084/flower_bouquet.png", 0.08, 0.05);
                    console.log('ğŸ† åˆæœŸåŒ–æ™‚ã«ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å¤‰æ›ã‚’è‡ªå‹•å®Ÿè¡Œã—ã¾ã—ãŸ');
                }, 2000);
            }, 1000);
            
            // èƒŒæ™¯ç”»åƒé©ç”¨é–¢æ•°
            window.setBouquetBackground = function(imagePath) {
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load(imagePath, function(texture) {
                    if (window.bgPlane) {
                        window.bgPlane.material = new THREE.MeshLambertMaterial({ 
                            map: texture,
                            transparent: true,
                            opacity: 0.8
                        });
                        console.log('ãƒ–ãƒ¼ã‚±èƒŒæ™¯ç”»åƒã‚’æ›´æ–°ã—ã¾ã—ãŸ:', imagePath);
                    }
                }, function(progress) {
                    console.log('ç”»åƒèª­ã¿è¾¼ã¿ä¸­:', (progress.loaded / progress.total * 100) + '%');
                }, function(error) {
                    console.error('ç”»åƒèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                });
            };
            
            // ç”»åƒã‚’ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã«å¤‰æ›ã™ã‚‹é–¢æ•°
            window.convertImageToParticles = function(imagePath, particleSize = 0.1, spacing = 0.1) {
                console.log('ğŸ† ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å¤‰æ›é–‹å§‹:', imagePath);
                
                // æ—¢å­˜ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ ãŒã‚ã‚Œã°å‰Šé™¤
                const existingParticles = scene.getObjectByName('particleSystem');
                if (existingParticles) {
                    scene.remove(existingParticles);
                    console.log('ğŸ—‘ï¸ æ—¢å­˜ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’å‰Šé™¤');
                }
                
                // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ä½œæˆã—ã¦ç”»åƒã‚’èª­ã¿è¾¼ã¿
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.crossOrigin = 'anonymous';
                img.onload = function() {
                    console.log(`ğŸ“ å…ƒç”»åƒã‚µã‚¤ã‚º: ${img.width}x${img.height}`);
                    
                    // ç”»åƒã‚µã‚¤ã‚ºã‚’èª¿æ•´ï¼ˆã‚ˆã‚Šç´°ã‹ãã™ã‚‹ãŸã‚ï¼‰
                    const maxSize = 200; // ã•ã‚‰ã«å¤§ãã
                    const scale = Math.min(maxSize / img.width, maxSize / img.height);
                    canvas.width = Math.floor(img.width * scale);
                    canvas.height = Math.floor(img.height * scale);
                    
                    console.log(`ğŸ–¼ï¸ å‡¦ç†ç”»åƒã‚µã‚¤ã‚º: ${canvas.width}x${canvas.height}`);
                    
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const pixels = imageData.data;
                    
                    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¸ã‚ªãƒ¡ãƒˆãƒªã¨ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’ä½œæˆ
                    const particleGeometry = new THREE.BufferGeometry();
                    const positions = [];
                    const colors = [];
                    let particleCount = 0;
                    
                    // ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ç”Ÿæˆï¼ˆã‚ˆã‚Šç´°ã‹ãï¼‰
                    for (let y = 0; y < canvas.height; y += 1) { // 1ãƒ”ã‚¯ã‚»ãƒ«ã”ã¨ï¼ˆã‚ˆã‚Šç´°ã‹ãï¼‰
                        for (let x = 0; x < canvas.width; x += 1) {
                            const index = (y * canvas.width + x) * 4;
                            const r = pixels[index] / 255;
                            const g = pixels[index + 1] / 255;
                            const b = pixels[index + 2] / 255;
                            const a = pixels[index + 3] / 255;
                            
                            // ã‚¤ãƒ©ã‚¹ãƒˆéƒ¨åˆ†ã®ã¿ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«åŒ–ï¼ˆé€æ˜éƒ¨åˆ†ã‚’é™¤å¤–ï¼‰
                            if (a > 0.5) { // ã‚¢ãƒ«ãƒ•ã‚¡å€¤50%ä»¥ä¸Šã®ä¸é€æ˜ãªéƒ¨åˆ†ã®ã¿
                                // å‹•çš„ãªãƒ—ãƒ¬ãƒ¼ãƒ³ã‚µã‚¤ã‚ºã«åˆã‚ã›ã‚‹
                                const currentPlaneWidth = window.planeWidth || 8;
                                const currentPlaneHeight = window.planeHeight || 4.5;
                                // ä½ç½®è¨ˆç®—ã‚’ä¿®æ­£ï¼ˆã‚ˆã‚Šç‹­ã„ç¯„å›²ã«ï¼‰
                                const px = ((x / canvas.width) - 0.5) * 2.0; // 8 â†’ 2ã«ç¸®å°
                                const py = ((y / canvas.height) - 0.5) * 1.2; // 4.5 â†’ 1.2ã«ç¸®å°
                                const pz = -1.7 + (Math.random() - 0.5) * 0.2; // ã‚«ãƒ¡ãƒ©ãŒè¦‹ã¦ã„ã‚‹ä½ç½®å‘¨è¾º
                                
                                positions.push(px, py, pz);
                                // ãƒ†ã‚¹ãƒˆç”¨ï¼šã™ã¹ã¦ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’æ˜ã‚‹ã„ç™½ã«ã™ã‚‹
                                colors.push(1.0, 1.0, 1.0); // ç™½è‰²ã§å¼·åˆ¶ãƒ†ã‚¹ãƒˆ
                                particleCount++;
                                
                                // ã‚«ãƒ©ãƒ¼ãƒ‡ãƒãƒƒã‚°ï¼ˆæœ€åˆã®10å€‹ã®ã¿ï¼‰
                                if (particleCount <= 10) {
                                    console.log(`ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«${particleCount}: RGB(${(r*255).toFixed(0)}, ${(g*255).toFixed(0)}, ${(b*255).toFixed(0)}) - æ­£è¦åŒ–RGB(${r.toFixed(3)}, ${g.toFixed(3)}, ${b.toFixed(3)})`);
                                }
                            }
                        }
                    }
                    
                    console.log(`âœ¨ ${particleCount} å€‹ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ç”Ÿæˆ`);
                    console.log(`ğŸ–¼ï¸ ã‚¢ãƒ«ãƒ•ã‚¡é–¾å€¤: a > 0.5`);
                    console.log(`ğŸ“Š ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚º: ${canvas.width}x${canvas.height}`);
                    console.log(`ğŸ¯ æœ€åˆã®5å€‹ã®ãƒ”ã‚¯ã‚»ãƒ«å€¤ã‚’ãƒã‚§ãƒƒã‚¯:`);
                    
                    // æœ€åˆã®æ•°ãƒ”ã‚¯ã‚»ãƒ«ã®ã‚¢ãƒ«ãƒ•ã‚¡å€¤ã‚’ãƒã‚§ãƒƒã‚¯
                    for (let i = 0; i < Math.min(25, canvas.width * canvas.height); i++) {
                        const index = i * 4;
                        const a = pixels[index + 3] / 255;
                        if (i < 5) {
                            console.log(`ãƒ”ã‚¯ã‚»ãƒ«${i}: alpha=${a.toFixed(3)}`);
                        }
                    }
                    
                    if (particleCount === 0) {
                        console.error('âŒ ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãŒç”Ÿæˆã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ');
                        console.error('ğŸ’¡ ã‚¢ãƒ«ãƒ•ã‚¡é–¾å€¤ã‚’ä¸‹ã’ã¦å†è©¦è¡Œã—ã¾ã™');
                        
                        // ã‚¢ãƒ«ãƒ•ã‚¡é–¾å€¤ã‚’ä¸‹ã’ã¦å†è©¦è¡Œ
                        for (let y = 0; y < canvas.height; y += 1) {
                            for (let x = 0; x < canvas.width; x += 1) {
                                const index = (y * canvas.width + x) * 4;
                                const a = pixels[index + 3] / 255;
                                if (a > 0.1) { // ã‚ˆã‚Šä½ã„é–¾å€¤ã§å†è©¦è¡Œ
                                    const r = pixels[index] / 255;
                                    const g = pixels[index + 1] / 255;
                                    const b = pixels[index + 2] / 255;
                                    
                                    const currentPlaneWidth = window.planeWidth || 8;
                                    const currentPlaneHeight = window.planeHeight || 4.5;
                                    const px = ((x / canvas.width) - 0.5) * currentPlaneWidth;
                                    const py = -((y / canvas.height) - 0.5) * currentPlaneHeight;
                                    const pz = (Math.random() - 0.5) * 0.5;
                                    
                                    positions.push(px, py, pz);
                                    colors.push(r, g, b);
                                    particleCount++;
                                }
                            }
                        }
                        console.log(`ğŸ”„ å†è©¦è¡Œçµæœ: ${particleCount} å€‹ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ç”Ÿæˆ (a > 0.1)`);
                    }
                    
                    if (particleCount === 0) {
                        console.error('âŒ ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãŒå…¨ãç”Ÿæˆã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ');
                        return;
                    }
                    
                    // ãƒãƒƒãƒ•ã‚¡å±æ€§ã‚’è¨­å®š
                    particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                    particleGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                    
                    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒãƒ†ãƒªã‚¢ãƒ«ï¼ˆå‹•ä½œç¢ºèªæ¸ˆã¿è¨­å®šã«å¤‰æ›´ï¼‰
                    const particleMaterial = new THREE.PointsMaterial({
                        size: particleSize * 3.0, // ã‚µã‚¤ã‚ºã‚’å¤§ãã
                        vertexColors: true,
                        transparent: false, // ãƒ†ã‚¹ãƒˆç”¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã¨åŒã˜è¨­å®š
                        // opacity: 1.0, // transparent: falseãªã®ã§ä¸è¦
                        // sizeAttenuation: true,
                        // alphaTest: 0.01,
                        // blending: THREE.AdditiveBlending // ä¸€æ—¦ç„¡åŠ¹åŒ–
                    });
                    
                    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚’ä½œæˆ
                    const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
                    particleSystem.name = 'particleSystem';
                    
                    // èƒŒæ™¯ç”»åƒã‚ˆã‚Šæ‰‹å‰ã«é…ç½®
                    if (window.bgPlane) {
                        particleSystem.position.copy(window.bgPlane.position);
                        particleSystem.position.z = window.bgPlane.position.z + 0.3; // ã‚‚ã£ã¨æ‰‹å‰
                        particleSystem.rotation.copy(window.bgPlane.rotation);
                        particleSystem.scale.copy(window.bgPlane.scale);
                    } else {
                        particleSystem.position.set(0, 2, -1.7);
                    }
                    
                    scene.add(particleSystem);
                    
                    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®ä½ç½®ã‚’ãƒ‡ãƒãƒƒã‚°
                    console.log('ğŸ“ ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ ä½ç½®:', particleSystem.position);
                    console.log('ğŸ“ èƒŒæ™¯ç”»åƒä½ç½®:', window.bgPlane ? window.bgPlane.position : 'ãªã—');
                    console.log('ğŸ“ ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚µã‚¤ã‚º:', particleMaterial.size);
                    console.log('ğŸ¨ ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰:', particleMaterial.blending === THREE.AdditiveBlending ? 'Additive' : 'Normal');
                    
                    // ğŸ” ã‚·ãƒ¼ãƒ³ç¢ºèª
                    console.log('ğŸ” ã‚·ãƒ¼ãƒ³å†…ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ•°:', scene.children.length);
                    console.log('ğŸ” ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ ãŒã‚·ãƒ¼ãƒ³ã«ã‚ã‚‹ã‹:', scene.children.includes(particleSystem));
                    
                    // ğŸ” é‡è¦ï¼š5ç§’å¾Œã«ã‚‚ã†ä¸€åº¦ç¢ºèª
                    setTimeout(() => {
                        const foundParticles = scene.getObjectByName('particleSystem');
                        console.log('ğŸ” 5ç§’å¾Œã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ :', foundParticles);
                        console.log('ğŸ” visibleçŠ¶æ…‹:', foundParticles ? foundParticles.visible : 'ãªã—');
                        console.log('ğŸ” ã‚¸ã‚ªãƒ¡ãƒˆãƒª:', foundParticles ? foundParticles.geometry : 'ãªã—');
                        console.log('ğŸ” ãƒãƒ†ãƒªã‚¢ãƒ«:', foundParticles ? foundParticles.material : 'ãªã—');
                        
                        // ğŸ“¹ ã‚«ãƒ¡ãƒ©æƒ…å ±ã‚’ãƒ‡ãƒãƒƒã‚°
                        console.log('ğŸ“¹ ã‚«ãƒ¡ãƒ©ä½ç½®:', camera.position);
                        console.log('ğŸ“¹ ã‚«ãƒ¡ãƒ©ãŒè¦‹ã¦ã„ã‚‹æ–¹å‘:', controls.target);
                        
                        // ğŸ¯ å¼·åˆ¶çš„ã«ã‚«ãƒ¡ãƒ©ã‚’ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã«å‘ã‘ã‚‹
                        console.log('ğŸ¯ ã‚«ãƒ¡ãƒ©ã‚’ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã«å‘ã‘ã¾ã™...');
                        camera.position.set(0, 2, 2); // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æ‰‹å‰ã«ç§»å‹•
                        controls.target.set(0, 2, -1.7); // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ç›´æ¥è¦‹ã‚‹
                        controls.update();
                        
                        // ãƒ†ã‚¹ãƒˆç”¨å›³å½¢ã‚’å‰Šé™¤ï¼ˆæˆåŠŸã—ãŸã®ã§ä¸è¦ï¼‰
                        
                        // ğŸš¨ ç·Šæ€¥ãƒ†ã‚¹ãƒˆï¼šã‚·ãƒ¼ãƒ³ã‹ã‚‰ç›´æ¥å–å¾—
                        const directParticles = scene.getObjectByName('particleSystem');
                        console.log('ğŸš¨ ã‚·ãƒ¼ãƒ³ã‹ã‚‰ç›´æ¥å–å¾—:', directParticles);
                        
                        if (directParticles) {
                            console.log('ğŸš¨ ç›´æ¥å–å¾—æˆåŠŸ - ä½ç½®ã‚’å¤‰æ›´ã—ã¾ã™');
                            directParticles.position.set(1, 1, -1); // æ˜ã‚‰ã‹ã«é•ã†ä½ç½®
                            directParticles.material.size = 5.0; // å·¨å¤§ã‚µã‚¤ã‚º
                            console.log('ğŸš¨ ç›´æ¥å¤‰æ›´å®Œäº†');
                            
                            // ğŸ” ã‚¸ã‚ªãƒ¡ãƒˆãƒªã®å®Ÿãƒ‡ãƒ¼ã‚¿ã‚’ç¢ºèª
                            const geo = directParticles.geometry;
                            const posAttr = geo.attributes.position;
                            const colorAttr = geo.attributes.color;
                            
                            console.log('ğŸ” positionå±æ€§:', posAttr);
                            console.log('ğŸ” colorå±æ€§:', colorAttr);
                            console.log('ğŸ” position.count:', posAttr ? posAttr.count : 'ãªã—');
                            console.log('ğŸ” color.count:', colorAttr ? colorAttr.count : 'ãªã—');
                            
                            // ğŸ” å®Ÿéš›ã®é…åˆ—ã®ä¸­èº«ã‚’ç¢ºèª
                            if (posAttr && posAttr.array) {
                                console.log('ğŸ” positioné…åˆ—ã®æœ€åˆã®9å€‹:', Array.from(posAttr.array.slice(0, 9)));
                                console.log('ğŸ” positioné…åˆ—ã®å‹:', posAttr.array.constructor.name);
                                console.log('ğŸ” positioné…åˆ—ã®é•·ã•:', posAttr.array.length);
                            }
                            
                            if (colorAttr && colorAttr.array) {
                                console.log('ğŸ” coloré…åˆ—ã®æœ€åˆã®9å€‹:', Array.from(colorAttr.array.slice(0, 9)));
                                console.log('ğŸ” coloré…åˆ—ã®å‹:', colorAttr.array.constructor.name);
                                console.log('ğŸ” coloré…åˆ—ã®é•·ã•:', colorAttr.array.length);
                            }
                            
                            // ğŸ¯ æœ€çµ‚æ‰‹æ®µï¼šã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’å®Œå…¨ã«å†æ§‹ç¯‰
                            console.log('ğŸ¯ æœ€çµ‚æ‰‹æ®µï¼šã‚¸ã‚ªãƒ¡ãƒˆãƒªå†æ§‹ç¯‰ãƒ†ã‚¹ãƒˆ');
                            
                            // æ–°ã—ã„ã‚·ãƒ³ãƒ—ãƒ«ãªã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’ä½œæˆ
                            const newGeo = new THREE.BufferGeometry();
                            const simplePos = [
                                0, 2, -1,   // ä¸­å¤®
                                0.5, 2, -1, // å³
                                -0.5, 2, -1 // å·¦
                            ];
                            const simpleColors = [
                                1, 0, 0, // èµ¤
                                0, 1, 0, // ç·‘  
                                0, 0, 1  // é’
                            ];
                            
                            newGeo.setAttribute('position', new THREE.Float32BufferAttribute(simplePos, 3));
                            newGeo.setAttribute('color', new THREE.Float32BufferAttribute(simpleColors, 3));
                            
                            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’ç½®ãæ›ãˆ
                            directParticles.geometry.dispose(); // å¤ã„ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’å‰Šé™¤
                            directParticles.geometry = newGeo;
                            
                            console.log('ğŸ¯ ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’3å€‹ã®RGBç²’å­ã«ç½®ãæ›ãˆã¾ã—ãŸ');
                        } else {
                            console.error('ğŸš¨ ç›´æ¥å–å¾—å¤±æ•—ï¼');
                        }
                        
                        // ğŸŒŸ å‹•ä½œç¢ºèªæ¸ˆã¿ã®æ–¹æ³•ã§èŠ±æŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ä½œæˆ
                        console.log('ğŸŒŸ å‹•ä½œç¢ºèªæ¸ˆã¿ã®æ–¹æ³•ã§èŠ±æŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ä½œæˆã—ã¾ã™');
                        
                        // ç”»åƒã‚’èª­ã¿è¾¼ã‚“ã§ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        const img = new Image();
                        
                        img.crossOrigin = 'anonymous';
                        img.onload = function() {
                            const maxSize = 300; // è¶…é«˜è§£åƒåº¦ã«
                            const scale = Math.min(maxSize / img.width, maxSize / img.height);
                            canvas.width = Math.floor(img.width * scale);
                            canvas.height = Math.floor(img.height * scale);
                            
                            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            const pixels = imageData.data;
                            
                            const positions = [];
                            const colors = [];
                            let count = 0;
                            
                            for (let y = 0; y < canvas.height; y += 1) { // é–“å¼•ãã‚’æ¸›ã‚‰ã—ã¦ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°ã‚¢ãƒƒãƒ—
                                for (let x = 0; x < canvas.width; x += 1) {
                                    const index = (y * canvas.width + x) * 4;
                                    const r = pixels[index] / 255;
                                    const g = pixels[index + 1] / 255;
                                    const b = pixels[index + 2] / 255;
                                    const a = pixels[index + 3] / 255;
                                    
                                    if (a > 0.1) { // å…ƒã®æ¡ä»¶ã«æˆ»ã™
                                        const px = ((x / canvas.width) - 0.5) * 8.0;
                                        const py = 2 + ((0.5 - y / canvas.height) * 4.5); // Yä½ç½®ã‚’èƒŒæ™¯ç”»åƒã«åˆã‚ã›ã‚‹
                                        const pz = -2 + (Math.random() - 0.5) * 0.2;
                                        
                                        positions.push(px, py, pz);
                                        colors.push(r, g, b); // å…ƒã®è‡ªç„¶ãªè‰²ã«æˆ»ã™
                                        count++;
                                    }
                                }
                            }
                            
                            console.log(`ğŸŒŸ ${count}å€‹ã®èŠ±æŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’æº–å‚™`);
                            
                            // ãƒ†ã‚¹ãƒˆç”¨ã¨åŒã˜æ–¹æ³•ã§ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ ä½œæˆ
                            const bouquetGeometry = new THREE.BufferGeometry();
                            bouquetGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                            bouquetGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                            
                            const bouquetMaterial = new THREE.PointsMaterial({
                                size: 0.03, // ã‚µã‚¤ã‚ºã‚’åŠåˆ†ã«ï¼ˆ0.06 â†’ 0.03ï¼‰
                                vertexColors: true,
                                transparent: false, // å…‰ã‚‹åŠ¹æœã‚’å‰Šé™¤
                                sizeAttenuation: true // è·é›¢ã«å¿œã˜ã¦ã‚µã‚¤ã‚ºå¤‰åŒ–
                            });
                            
                            const bouquetParticles = new THREE.Points(bouquetGeometry, bouquetMaterial);
                            bouquetParticles.name = 'bouquetParticles';
                            scene.add(bouquetParticles);
                            
                            console.log('ğŸŒŸ èŠ±æŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®Œæˆï¼');
                        };
                        
                        img.src = "http://localhost:8084/flower_bouquet.png";
                        
                        // ğŸ” é‡è¦ï¼šã‚·ãƒ¼ãƒ³å†…ã®å…¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚’ç¢ºèª
                        console.log('ğŸ” ã‚·ãƒ¼ãƒ³å†…ã®å…¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ :');
                        scene.children.forEach((child, index) => {
                            if (child.type === 'Points') {
                                console.log(`  ${index}: ${child.name} - ä½ç½®:`, child.position, '- å¯è¦–:', child.visible);
                                if (child.geometry && child.geometry.attributes.position) {
                                    const count = child.geometry.attributes.position.array.length / 3;
                                    console.log(`    ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°: ${count}`);
                                }
                            }
                        });
                        
                        // ğŸ”µ å…ƒã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ãƒ‡ãƒ¼ã‚¿ã‚’è©³ã—ãèª¿æŸ»
                        console.log('ğŸ” foundParticles:', foundParticles);
                        console.log('ğŸ” foundParticles === null?', foundParticles === null);
                        console.log('ğŸ” foundParticles === undefined?', foundParticles === undefined);
                        
                        if (foundParticles) {
                            const geo = foundParticles.geometry;
                            const mat = foundParticles.material;
                            
                            console.log('ğŸ” ã‚¸ã‚ªãƒ¡ãƒˆãƒªè©³ç´°:');
                            console.log('  - ä½ç½®ãƒ‡ãƒ¼ã‚¿é•·ã•:', geo.attributes.position ? geo.attributes.position.array.length : 'ãªã—');
                            console.log('  - è‰²ãƒ‡ãƒ¼ã‚¿é•·ã•:', geo.attributes.color ? geo.attributes.color.array.length : 'ãªã—');
                            console.log('  - æœ€åˆã®3ã¤ã®ä½ç½®:', geo.attributes.position ? Array.from(geo.attributes.position.array.slice(0, 9)) : 'ãªã—');
                            console.log('  - æœ€åˆã®3ã¤ã®è‰²:', geo.attributes.color ? Array.from(geo.attributes.color.array.slice(0, 9)) : 'ãªã—');
                            
                            console.log('ğŸ” ãƒãƒ†ãƒªã‚¢ãƒ«è©³ç´°:');
                            console.log('  - ã‚µã‚¤ã‚º:', mat.size);
                            console.log('  - vertexColors:', mat.vertexColors);
                            console.log('  - transparent:', mat.transparent);
                            console.log('  - opacity:', mat.opacity);
                            
                            // ğŸ¯ æ±ºå®šçš„ãƒ†ã‚¹ãƒˆï¼šãƒ†ã‚¹ãƒˆç”¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã¨å…¨ãåŒã˜ä½ç½®ã«å¼·åˆ¶ç§»å‹•
                            foundParticles.position.set(0, 0, 0); // ãƒ†ã‚¹ãƒˆç”¨ã¨å…¨ãåŒã˜ä½ç½®
                            foundParticles.material.size = 2.0; // ãƒ†ã‚¹ãƒˆç”¨ã‚ˆã‚Šå¤§ãã
                            
                            // ã•ã‚‰ã«ï¼šæœ€åˆã®å°‘æ•°ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ä½ç½®ã‚’ç›´æ¥ä¸Šæ›¸ã
                            const pos = foundParticles.geometry.attributes.position.array;
                            const colors = foundParticles.geometry.attributes.color.array;
                            
                            // æœ€åˆã®10å€‹ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ç›®ç«‹ã¤ä½ç½®ã«å¼·åˆ¶é…ç½®
                            for (let i = 0; i < Math.min(30, pos.length); i += 3) {
                                pos[i] = (i/3) * 0.3 - 1.5; // X: -1.5ã‹ã‚‰1.5ã¾ã§ä¸¦ã¹ã‚‹
                                pos[i+1] = 2; // Y: å›ºå®š
                                pos[i+2] = -1.5; // Z: å›ºå®š
                                
                                // è‰²ã‚‚å¼·åˆ¶çš„ã«èµ¤ã«ã™ã‚‹
                                colors[i/3*3] = 1.0; // R
                                colors[i/3*3+1] = 0.0; // G
                                colors[i/3*3+2] = 0.0; // B
                            }
                            
                            foundParticles.geometry.attributes.position.needsUpdate = true;
                            foundParticles.geometry.attributes.color.needsUpdate = true;
                            
                            console.log('ğŸ¯ æœ€åˆã®10å€‹ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’èµ¤è‰²ã§ä¸€åˆ—ã«å¼·åˆ¶é…ç½®');
                        }
                        
                    }, 5000);
                    
                    // èƒŒæ™¯ç”»åƒã¯ãã®ã¾ã¾ï¼ˆãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãŒè¦‹ãˆã‚‹ã¯ãšï¼‰
                    // if (window.bgPlane) {
                    //     window.bgPlane.material.opacity = 0.5;
                    // }
                    
                    console.log('ğŸ† ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å¤‰æ›å®Œäº†ï¼èƒŒæ™¯ç”»åƒã®ä¸Šã«ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’é…ç½®');
                    
                    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                    particleSystem.userData = { 
                        originalPositions: positions.slice(),
                        time: 0,
                        rotating: true
                    };
                    objects.set('particleSystem', particleSystem);
                };
                
                img.onerror = function(error) {
                    console.error('âŒ ç”»åƒèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                };
                
                img.src = imagePath;
            };

            // åˆæœŸãƒ–ãƒ¼ã‚±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆèŠ±ç“¶ï¼‰ã‚’å‰Šé™¤

            // WebSocketæ¥ç¶šé–‹å§‹
            connectWebSocket();
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—é–‹å§‹
            animate();
        }

        // ãƒ–ãƒ¼ã‚±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¿½åŠ 
        function addBouquetObject(id, type, position, color) {
            let geometry;
            
            switch(type) {
                case 'vase':
                    // èŠ±ç“¶ï¼ˆä¸‹ãŒå¤ªã„å††æŸ±ï¼‰
                    geometry = new THREE.CylinderGeometry(0.3, 0.5, 1, 16);
                    break;
                case 'rose':
                    // ãƒãƒ©ï¼ˆè¤‡æ•°ã®çƒä½“ã‚’çµ„ã¿åˆã‚ã›ï¼‰
                    geometry = new THREE.SphereGeometry(0.2, 16, 16);
                    break;
                case 'tulip':
                    // ãƒãƒ¥ãƒ¼ãƒªãƒƒãƒ—ï¼ˆæ¥•å††ä½“ï¼‰
                    geometry = new THREE.SphereGeometry(0.25, 12, 8);
                    geometry.scale(0.8, 1.5, 0.8);
                    break;
                case 'sunflower':
                    // ã²ã¾ã‚ã‚Šï¼ˆå¹³ãŸã„å††ï¼‰
                    geometry = new THREE.CylinderGeometry(0.4, 0.4, 0.1, 16);
                    break;
                case 'hibiscus':
                    // ãƒã‚¤ãƒ“ã‚¹ã‚«ã‚¹ï¼ˆæ˜Ÿå‹ã£ã½ãï¼‰
                    geometry = new THREE.ConeGeometry(0.3, 0.2, 5);
                    break;
                case 'stem':
                    // èŒï¼ˆç´°ã„å††æŸ±ï¼‰
                    geometry = new THREE.CylinderGeometry(0.02, 0.02, 1.5, 8);
                    break;
                case 'leaf':
                    // è‘‰ã£ã±ï¼ˆå¹³ãŸã„æ¥•å††ï¼‰
                    geometry = new THREE.SphereGeometry(0.2, 12, 6);
                    geometry.scale(2, 0.1, 1);
                    break;
                case 'ribbon':
                    // ãƒªãƒœãƒ³ï¼ˆè–„ã„ç®±ï¼‰
                    geometry = new THREE.BoxGeometry(0.8, 0.05, 0.1);
                    break;
                default:
                    geometry = new THREE.SphereGeometry(0.2, 16, 16);
            }

            const material = new THREE.MeshLambertMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);
            
            mesh.position.set(position[0], position[1], position[2]);
            mesh.castShadow = true;
            mesh.userData = { id, type, rotating: false, rotationSpeed: 0 };
            
            scene.add(mesh);
            objects.set(id, mesh);
            
            sendSceneState();
        }

        // ã‚³ãƒãƒ³ãƒ‰å‡¦ç†
        function handleCommand(command) {
            console.log('å—ä¿¡ã‚³ãƒãƒ³ãƒ‰:', command);
            
            switch(command.action) {
                case 'addObject':
                    addBouquetObject(
                        command.id || `object_${Date.now()}`,
                        command.type || 'rose',
                        command.position || [0, 1, 0],
                        command.color || '#ff69b4'
                    );
                    break;
                    
                case 'moveObject':
                    const moveObj = objects.get(command.id);
                    if (moveObj) {
                        moveObj.position.set(...command.position);
                        sendSceneState();
                    }
                    break;
                    
                case 'removeObject':
                    const removeObj = objects.get(command.id);
                    if (removeObj) {
                        scene.remove(removeObj);
                        objects.delete(command.id);
                        sendSceneState();
                    }
                    break;
                    
                case 'startRotation':
                    const rotateObj = objects.get(command.id);
                    if (rotateObj) {
                        rotateObj.userData.rotating = true;
                        rotateObj.userData.rotationSpeed = command.speed || 0.01;
                    }
                    break;
                    
                case 'stopRotation':
                    const stopObj = objects.get(command.id);
                    if (stopObj) {
                        stopObj.userData.rotating = false;
                        stopObj.userData.rotationSpeed = 0;
                    }
                    break;
                    
                case 'setBouquetBackground':
                    if (command.imagePath) {
                        setBouquetBackground(command.imagePath);
                        console.log('ãƒ–ãƒ¼ã‚±èƒŒæ™¯ç”»åƒã‚’è¨­å®š:', command.imagePath);
                    }
                    break;
                    
                case 'convertToParticles':
                    if (command.imagePath) {
                        convertImageToParticles(command.imagePath, command.particleSize || 0.02, command.spacing || 0.05);
                        console.log('ç”»åƒã‚’ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã«å¤‰æ›:', command.imagePath);
                    }
                    break;
            }
        }

        // ã‚·ãƒ¼ãƒ³çŠ¶æ…‹é€ä¿¡
        function sendSceneState() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const state = {
                    timestamp: Date.now(),
                    data: Array.from(objects.entries()).map(([id, obj]) => ({
                        id,
                        type: obj.userData.type,
                        position: [obj.position.x, obj.position.y, obj.position.z],
                        rotation: [obj.rotation.x, obj.rotation.y, obj.rotation.z],
                        color: '#' + obj.material.color.getHexString(),
                        rotating: obj.userData.rotating,
                        rotationSpeed: obj.userData.rotationSpeed
                    }))
                };
                ws.send(JSON.stringify(state));
            }
        }

        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
        function animate() {
            requestAnimationFrame(animate);
            
            // å›è»¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            objects.forEach(obj => {
                if (obj.userData.rotating) {
                    obj.rotation.y += obj.userData.rotationSpeed;
                }
            });
            
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            const particleSystem = scene.getObjectByName('particleSystem');
            if (particleSystem && particleSystem.userData.rotating) {
                particleSystem.userData.time += 0.01;
                
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’è»½ãæºã‚‰ã™
                const positions = particleSystem.geometry.attributes.position.array;
                const originalPositions = particleSystem.userData.originalPositions;
                
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i] = originalPositions[i] + Math.sin(particleSystem.userData.time + i * 0.01) * 0.1;
                    positions[i + 1] = originalPositions[i + 1] + Math.cos(particleSystem.userData.time + i * 0.01) * 0.05;
                    positions[i + 2] = originalPositions[i + 2] + Math.sin(particleSystem.userData.time * 0.5 + i * 0.005) * 0.2;
                }
                
                particleSystem.geometry.attributes.position.needsUpdate = true;
                
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å…¨ä½“ã‚’ã‚†ã£ãã‚Šå›è»¢
                particleSystem.rotation.y += 0.005;
            }
            
            controls.update();
            renderer.render(scene, camera);
        }

        // ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // åˆæœŸåŒ–å®Ÿè¡Œ
        init();
    </script>
</body>
</html>